// lib/yolo.min.js
// EasyYOLO 核心 YOLO 引擎 - 純前端精簡版

(function(global) {
    'use strict';
    
    // YOLO 核心類別
    class YOLOEngine {
        constructor(config = {}) {
            this.config = {
                modelPath: config.modelPath || '/model/yolo-tiny.tfjs',
                inputSize: config.inputSize || 416,
                threshold: config.threshold || 0.5,
                nmsThreshold: config.nmsThreshold || 0.4,
                maxBoxes: config.maxBoxes || 100,
                // 繁體中文類別名稱
                classes: config.classes || [
                    '人', '腳踏車', '汽車', '機車', '飛機', '公車', '火車', '卡車', '船',
                    '紅綠燈', '消防栓', '停車標誌', '停車計時器', '長椅', '鳥', '貓', '狗',
                    '馬', '羊', '牛', '大象', '熊', '斑馬', '長頸鹿', '背包', '雨傘',
                    '手提包', '領帶', '行李箱', '飛盤', '滑雪板', '滑雪板', '運動球',
                    '風箏', '棒球棒', '棒球手套', '滑板', '衝浪板', '網球拍', '瓶子',
                    '酒杯', '杯子', '叉子', '刀', '湯匙', '碗', '香蕉', '蘋果', '三明治',
                    '橘子', '花椰菜', '胡蘿蔔', '熱狗', '披薩', '甜甜圈', '蛋糕', '椅子',
                    '沙發', '盆栽', '床', '餐桌', '馬桶', '電視', '筆記型電腦', '滑鼠',
                    '遙控器', '鍵盤', '手機', '微波爐', '烤箱', '烤麵包機', '水槽', '冰箱',
                    '書', '時鐘', '花瓶', '剪刀', '泰迪熊', '吹風機', '牙刷'
                ],
                ...config
            };
            
            this.model = null;
            this.isReady = false;
            this.anchors = this.generateAnchors();
        }
        
        // 初始化 YOLO 模型
        async initialize() {
            try {
                console.log('正在初始化 YOLO 引擎...');
                
                // 檢查 TensorFlow.js 是否已載入
                if (typeof tf === 'undefined') {
                    throw new Error('TensorFlow.js 尚未載入');
                }
                
                // 使用預訓練模型或載入自訂模型
                if (this.config.modelPath.includes('tiny')) {
                    this.model = await this.createTinyYOLO();
                } else {
                    this.model = await tf.loadLayersModel(this.config.modelPath);
                }
                
                this.isReady = true;
                console.log('YOLO 引擎初始化完成');
                
                return true;
            } catch (error) {
                console.error('YOLO 引擎初始化失敗:', error);
                return false;
            }
        }
        
        // 創建精簡版 YOLO 模型 (適用於瀏覽器)
        async createTinyYOLO() {
            // 建立簡化的 YOLO 架構
            const model = tf.sequential({
                layers: [
                    // 輸入層
                    tf.layers.inputLayer({ inputShape: [this.config.inputSize, this.config.inputSize, 3] }),
                    
                    // 卷積層組 1
                    tf.layers.conv2d({
                        filters: 16,
                        kernelSize: 3,
                        padding: 'same',
                        activation: 'relu'
                    }),
                    tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }),
                    
                    // 卷積層組 2
                    tf.layers.conv2d({
                        filters: 32,
                        kernelSize: 3,
                        padding: 'same',
                        activation: 'relu'
                    }),
                    tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }),
                    
                    // 卷積層組 3
                    tf.layers.conv2d({
                        filters: 64,
                        kernelSize: 3,
                        padding: 'same',
                        activation: 'relu'
                    }),
                    tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }),
                    
                    // 輸出層
                    tf.layers.conv2d({
                        filters: (4 + 1 + this.config.classes.length) * 5, // (座標 + 信心度 + 類別) * 錨點數
                        kernelSize: 1,
                        padding: 'same',
                        activation: 'linear'
                    })
                ]
            });
            
            // 載入預訓練權重（如果有）
            try {
                const weights = await fetch('/model/yolo-tiny-weights.bin');
                if (weights.ok) {
                    const weightData = await weights.arrayBuffer();
                    const weightTensors = tf.io.decodeWeights(weightData);
                    model.setWeights(weightTensors);
                }
            } catch (e) {
                console.log('使用隨機權重初始化模型');
            }
            
            return model;
        }
        
        // 生成錨點
        generateAnchors() {
            return [
                [0.57273, 0.677385],
                [1.87446, 2.06253],
                [3.33843, 5.47434],
                [7.88282, 3.52778],
                [9.77052, 9.16828]
            ];
        }
        
        // 執行物件偵測
        async detect(imageElement) {
            if (!this.isReady) {
                throw new Error('YOLO 引擎尚未初始化');
            }
            
            return tf.tidy(() => {
                // 圖片預處理
                const imageTensor = this.preprocessImage(imageElement);
                
                // 執行推論
                const predictions = this.model.predict(imageTensor);
                
                // 解析預測結果
                const boxes = this.parseOutput(predictions, imageElement);
                
                // 非最大抑制
                const filteredBoxes = this.nonMaxSuppression(boxes);
                
                return filteredBoxes;
            });
        }
        
        // 圖片預處理
        preprocessImage(imageElement) {
            return tf.tidy(() => {
                // 轉換為張量
                let imageTensor = tf.browser.fromPixels(imageElement);
                
                // 調整大小
                imageTensor = tf.image.resizeBilinear(imageTensor, [this.config.inputSize, this.config.inputSize]);
                
                // 正規化 (0-255 -> 0-1)
                imageTensor = imageTensor.div(255.0);
                
                // 添加批次維度
                imageTensor = imageTensor.expandDims(0);
                
                return imageTensor;
            });
        }
        
        // 解析模型輸出
        parseOutput(predictions, imageElement) {
            const predictionData = predictions.dataSync();
            const boxes = [];
            
            const gridSize = Math.floor(this.config.inputSize / 32);
            const numAnchors = this.anchors.length;
            const outputSize = 4 + 1 + this.config.classes.length;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let a = 0; a < numAnchors; a++) {
                        const index = (y * gridSize + x) * numAnchors * outputSize + a * outputSize;
                        
                        // 提取預測值
                        const tx = predictionData[index];
                        const ty = predictionData[index + 1];
                        const tw = predictionData[index + 2];
                        const th = predictionData[index + 3];
                        const confidence = this.sigmoid(predictionData[index + 4]);
                        
                        if (confidence > this.config.threshold) {
                            // 計算實際座標
                            const bx = (x + this.sigmoid(tx)) / gridSize;
                            const by = (y + this.sigmoid(ty)) / gridSize;
                            const bw = Math.exp(tw) * this.anchors[a][0] / gridSize;
                            const bh = Math.exp(th) * this.anchors[a][1] / gridSize;
                            
                            // 類別機率
                            const classProbs = [];
                            for (let c = 0; c < this.config.classes.length; c++) {
                                classProbs.push(this.sigmoid(predictionData[index + 5 + c]));
                            }
                            
                            // 找出最高機率的類別
                            const maxProb = Math.max(...classProbs);
                            const classIndex = classProbs.indexOf(maxProb);
                            
                            // 計算最終信心度
                            const finalConfidence = confidence * maxProb;
                            
                            if (finalConfidence > this.config.threshold) {
                                // 轉換到圖片座標
                                const imageWidth = imageElement.width;
                                const imageHeight = imageElement.height;
                                
                                boxes.push({
                                    x: (bx - bw / 2) * imageWidth,
                                    y: (by - bh / 2) * imageHeight,
                                    width: bw * imageWidth,
                                    height: bh * imageHeight,
                                    confidence: finalConfidence,
                                    class: classIndex,
                                    className: this.config.classes[classIndex]
                                });
                            }
                        }
                    }
                }
            }
            
            return boxes;
        }
        
        // Sigmoid 函數
        sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }
        
        // 非最大抑制
        nonMaxSuppression(boxes) {
            // 按信心度排序
            boxes.sort((a, b) => b.confidence - a.confidence);
            
            const selected = [];
            const processed = new Set();
            
            for (let i = 0; i < boxes.length && selected.length < this.config.maxBoxes; i++) {
                if (processed.has(i)) continue;
                
                const boxA = boxes[i];
                selected.push(boxA);
                processed.add(i);
                
                // 檢查剩餘的框
                for (let j = i + 1; j < boxes.length; j++) {
                    if (processed.has(j)) continue;
                    
                    const boxB = boxes[j];
                    
                    // 如果是同一類別且IoU高於閾值，則移除
                    if (boxA.class === boxB.class) {
                        const iou = this.calculateIoU(boxA, boxB);
                        if (iou > this.config.nmsThreshold) {
                            processed.add(j);
                        }
                    }
                }
            }
            
            return selected;
        }
        
        // 計算交併比 (IoU)
        calculateIoU(boxA, boxB) {
            const xA = Math.max(boxA.x, boxB.x);
            const yA = Math.max(boxA.y, boxB.y);
            const xB = Math.min(boxA.x + boxA.width, boxB.x + boxB.width);
            const yB = Math.min(boxA.y + boxA.height, boxB.y + boxB.height);
            
            const intersection = Math.max(0, xB - xA) * Math.max(0, yB - yA);
            const boxAArea = boxA.width * boxA.height;
            const boxBArea = boxB.width * boxB.height;
            const union = boxAArea + boxBArea - intersection;
            
            return intersection / union;
        }
        
        // 釋放資源
        dispose() {
            if (this.model) {
                this.model.dispose();
            }
        }
        
        // 取得模型資訊
        getModelInfo() {
            return {
                inputSize: this.config.inputSize,
                classes: this.config.classes.length,
                classNames: this.config.classes,
                threshold: this.config.threshold,
                isReady: this.isReady
            };
        }
        
        // 更新配置
        updateConfig(newConfig) {
            Object.assign(this.config, newConfig);
        }
        
        // 自訂類別
        setClasses(classes) {
            this.config.classes = classes;
        }
    }
    
    // 工具函數
    const YOLOUtils = {
        // 繪製偵測結果
        drawDetections(canvas, detections, options = {}) {
            const ctx = canvas.getContext('2d');
            const fontFamily = options.fontFamily || '"Microsoft JhengHei", "微軟正黑體", sans-serif';
            const fontSize = options.fontSize || 16;
            
            detections.forEach(detection => {
                // 偵測框顏色
                const color = options.color || this.getColorForClass(detection.class);
                
                // 繪製框
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(detection.x, detection.y, detection.width, detection.height);
                
                // 繪製標籤背景
                const label = `${detection.className} ${(detection.confidence * 100).toFixed(1)}%`;
                ctx.font = `${fontSize}px ${fontFamily}`;
                const textMetrics = ctx.measureText(label);
                const textHeight = fontSize + 4;
                
                ctx.fillStyle = color;
                ctx.fillRect(detection.x, detection.y - textHeight, textMetrics.width + 8, textHeight);
                
                // 繪製標籤文字
                ctx.fillStyle = '#ffffff';
                ctx.fillText(label, detection.x + 4, detection.y - 4);
            });
        },
        
        // 根據類別取得顏色
        getColorForClass(classIndex) {
            const colors = [
                '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                '#800000', '#008000', '#000080', '#808000', '#800080', '#008080',
                '#C0C0C0', '#808080', '#FF9999', '#99FF99', '#9999FF', '#FFFF99'
            ];
            return colors[classIndex % colors.length];
        },
        
        // 預處理影片幀
        preprocessVideoFrame(video, targetSize = 416) {
            const canvas = document.createElement('canvas');
            canvas.width = targetSize;
            canvas.height = targetSize;
            const ctx = canvas.getContext('2d');
            
            // 保持比例縮放
            const scale = Math.min(targetSize / video.videoWidth, targetSize / video.videoHeight);
            const width = video.videoWidth * scale;
            const height = video.videoHeight * scale;
            const x = (targetSize - width) / 2;
            const y = (targetSize - height) / 2;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, targetSize, targetSize);
            ctx.drawImage(video, x, y, width, height);
            
            return canvas;
        },
        
        // 效能監控
        createPerformanceMonitor() {
            let frameCount = 0;
            let totalTime = 0;
            let lastTime = performance.now();
            
            return {
                startFrame() {
                    lastTime = performance.now();
                },
                
                endFrame() {
                    const currentTime = performance.now();
                    const frameTime = currentTime - lastTime;
                    totalTime += frameTime;
                    frameCount++;
                    
                    return {
                        frameTime,
                        avgTime: totalTime / frameCount,
                        fps: 1000 / (totalTime / frameCount)
                    };
                },
                
                reset() {
                    frameCount = 0;
                    totalTime = 0;
                    lastTime = performance.now();
                }
            };
        },
        
        // 批次偵測
        async batchDetect(yoloEngine, images, options = {}) {
            const results = [];
            const batchSize = options.batchSize || 4;
            
            for (let i = 0; i < images.length; i += batchSize) {
                const batch = images.slice(i, i + batchSize);
                const batchResults = await Promise.all(
                    batch.map(image => yoloEngine.detect(image))
                );
                results.push(...batchResults);
            }
            
            return results;
        },
        
        // 儲存偵測結果
        saveDetectionResults(detections, filename = 'detections.json') {
            const data = {
                timestamp: new Date().toISOString(),
                detections: detections,
                summary: {
                    totalObjects: detections.length,
                    classes: [...new Set(detections.map(d => d.className))],
                    avgConfidence: detections.reduce((sum, d) => sum + d.confidence, 0) / detections.length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
        }
    };
    
    // 註冊到全域
    global.YOLOEngine = YOLOEngine;
    global.YOLOUtils = YOLOUtils;
    
    // 如果是模組環境
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = { YOLOEngine, YOLOUtils };
    }
    
})(typeof window !== 'undefined' ? window : this);