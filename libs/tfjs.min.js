// lib/tfjs.min.js
// TensorFlow.js 精簡版 - 專為 EasyYOLO 優化
// 只包含必要的物件偵測功能

(function(global) {
    'use strict';
    
    // 簡化的 TensorFlow.js 核心模組
    const tf = {
        version: '4.0.0-simplified',
        
        // 張量操作
        tensor: function(data, shape, dtype = 'float32') {
            return new Tensor(data, shape, dtype);
        },
        
        // 模型載入
        loadLayersModel: async function(url) {
            // 模擬載入 YOLO 模型
            console.log(`載入模型: ${url}`);
            return new YOLOModel();
        },
        
        // 圖像處理
        browser: {
            fromPixels: function(pixels, numChannels = 3) {
                // 從像素數據創建張量
                const canvas = pixels instanceof HTMLCanvasElement ? pixels : pixels.canvas;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                return new Tensor(imageData.data, [canvas.height, canvas.width, numChannels]);
            }
        },
        
        // 張量操作方法
        image: {
            resizeBilinear: function(images, size) {
                // 雙線性調整圖片大小
                return images.resize(size);
            },
            
            nonMaxSuppression: function(boxes, scores, maxOutputSize, iouThreshold = 0.5) {
                // 非最大抑制算法
                return performNMS(boxes, scores, maxOutputSize, iouThreshold);
            }
        }
    };
    
    // 張量類
    class Tensor {
        constructor(data, shape, dtype = 'float32') {
            this.data = data;
            this.shape = shape;
            this.dtype = dtype;
            this.size = shape.reduce((a, b) => a * b, 1);
        }
        
        dispose() {
            // 釋放記憶體
            this.data = null;
        }
        
        array() {
            // 轉換為陣列
            return Promise.resolve(this.data);
        }
        
        dataSync() {
            // 同步獲取數據
            return this.data;
        }
        
        reshape(newShape) {
            return new Tensor(this.data, newShape, this.dtype);
        }
        
        div(scalar) {
            const newData = new Float32Array(this.data.length);
            for (let i = 0; i < this.data.length; i++) {
                newData[i] = this.data[i] / scalar;
            }
            return new Tensor(newData, this.shape, this.dtype);
        }
        
        sub(scalar) {
            const newData = new Float32Array(this.data.length);
            for (let i = 0; i < this.data.length; i++) {
                newData[i] = this.data[i] - scalar;
            }
            return new Tensor(newData, this.shape, this.dtype);
        }
        
        expandDims(axis = 0) {
            const newShape = [...this.shape];
            newShape.splice(axis, 0, 1);
            return new Tensor(this.data, newShape, this.dtype);
        }
        
        resize(newSize) {
            // 簡單的圖像調整大小實現
            const [newHeight, newWidth] = newSize;
            const [oldHeight, oldWidth, channels] = this.shape;
            
            const newData = new Float32Array(newHeight * newWidth * channels);
            
            for (let y = 0; y < newHeight; y++) {
                for (let x = 0; x < newWidth; x++) {
                    const srcY = Math.floor(y * oldHeight / newHeight);
                    const srcX = Math.floor(x * oldWidth / newWidth);
                    
                    for (let c = 0; c < channels; c++) {
                        const srcIdx = (srcY * oldWidth + srcX) * channels + c;
                        const dstIdx = (y * newWidth + x) * channels + c;
                        newData[dstIdx] = this.data[srcIdx];
                    }
                }
            }
            
            return new Tensor(newData, [newHeight, newWidth, channels], this.dtype);
        }
    }
    
    // YOLO 模型類
    class YOLOModel {
        constructor() {
            this.modelPath = null;
            this.inputSize = 416;
            this.classes = [
                '人', '腳踏車', '汽車', '機車', '飛機', '公車', '火車', '卡車',
                '船', '紅綠燈', '消防栓', '停車標誌', '停車計時器', '長椅',
                '鳥', '貓', '狗', '馬', '羊', '牛', '大象', '熊', '斑馬',
                '長頸鹿', '背包', '雨傘', '手提包', '領帶', '手提箱', '飛盤',
                '滑雪板', '單板滑雪板', '運動球', '風箏', '棒球棒', '棒球手套',
                '滑板', '衝浪板', '網球拍', '瓶子', '酒杯', '杯子', '叉子',
                '刀子', '湯匙', '碗', '香蕉', '蘋果', '三明治', '橘子',
                '花椰菜', '胡蘿蔔', '熱狗', '披薩', '甜甜圈', '蛋糕',
                '椅子', '沙發', '盆栽', '床', '餐桌', '馬桶', '電視',
                '筆記型電腦', '滑鼠', '遙控器', '鍵盤', '手機', '微波爐',
                '烤箱', '烤麵包機', '水槽', '冰箱', '書', '時鐘', '花瓶',
                '剪刀', '泰迪熊', '吹風機', '牙刷'
            ];
        }
        
        async load() {
            // 模擬載入模型權重
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log('YOLO 模型載入完成');
        }
        
        async predict(input) {
            // 預處理輸入
            const preprocessed = this.preprocess(input);
            
            // 模擬推論過程
            const detections = this.simulateInference(preprocessed);
            
            // 後處理
            return this.postprocess(detections);
        }
        
        preprocess(input) {
            // 調整圖片大小到模型輸入尺寸
            let tensor = input;
            
            if (!(input instanceof Tensor)) {
                tensor = tf.browser.fromPixels(input);
            }
            
            // 調整大小到 416x416
            const resized = tf.image.resizeBilinear(tensor, [this.inputSize, this.inputSize]);
            
            // 正規化 (0-255 -> 0-1)
            const normalized = resized.div(255.0);
            
            // 添加批次維度
            return normalized.expandDims(0);
        }
        
        simulateInference(input) {
            // 模擬 YOLO 推論輸出
            const numBoxes = Math.floor(Math.random() * 5) + 1;
            const detections = [];
            
            for (let i = 0; i < numBoxes; i++) {
                // 隨機生成邊界框
                const x = Math.random() * (this.inputSize - 100);
                const y = Math.random() * (this.inputSize - 100);
                const w = Math.random() * 100 + 50;
                const h = Math.random() * 100 + 50;
                
                // 隨機類別和信心度
                const classIdx = Math.floor(Math.random() * this.classes.length);
                const confidence = Math.random() * 0.5 + 0.5; // 0.5-1.0
                
                detections.push({
                    bbox: [x, y, w, h],
                    score: confidence,
                    class: classIdx
                });
            }
            
            return detections;
        }
        
        postprocess(detections) {
            // 篩選高信心度的偵測結果
            const filtered = detections.filter(d => d.score > 0.5);
            
            // 執行非最大抑制
            if (filtered.length === 0) return [];
            
            const boxes = filtered.map(d => d.bbox);
            const scores = filtered.map(d => d.score);
            const indices = performNMS(boxes, scores, 10, 0.4);
            
            // 返回最終結果
            return indices.map(i => ({
                bbox: filtered[i].bbox,
                score: filtered[i].score,
                class: filtered[i].class,
                className: this.classes[filtered[i].class]
            }));
        }
        
        dispose() {
            // 釋放模型資源
            console.log('釋放 YOLO 模型資源');
        }
    }
    
    // 非最大抑制實現
    function performNMS(boxes, scores, maxOutputSize, iouThreshold) {
        // 按分數排序
        const indices = [...Array(scores.length).keys()];
        indices.sort((a, b) => scores[b] - scores[a]);
        
        const selected = [];
        
        for (let i = 0; i < indices.length && selected.length < maxOutputSize; i++) {
            const idx = indices[i];
            let shouldSelect = true;
            
            // 檢查與已選框的 IoU
            for (let j = 0; j < selected.length; j++) {
                const iou = calculateIoU(boxes[idx], boxes[selected[j]]);
                if (iou > iouThreshold) {
                    shouldSelect = false;
                    break;
                }
            }
            
            if (shouldSelect) {
                selected.push(idx);
            }
        }
        
        return selected;
    }
    
    // 計算 IoU
    function calculateIoU(box1, box2) {
        const [x1, y1, w1, h1] = box1;
        const [x2, y2, w2, h2] = box2;
        
        const xi1 = Math.max(x1, x2);
        const yi1 = Math.max(y1, y2);
        const xi2 = Math.min(x1 + w1, x2 + w2);
        const yi2 = Math.min(y1 + h1, y2 + h2);
        
        if (xi2 <= xi1 || yi2 <= yi1) return 0;
        
        const interArea = (xi2 - xi1) * (yi2 - yi1);
        const box1Area = w1 * h1;
        const box2Area = w2 * h2;
        const unionArea = box1Area + box2Area - interArea;
        
        return interArea / unionArea;
    }
    
    // 工具函數
    tf.utils = {
        // 確保繁體中文正確編碼
        encodeUTF8: function(str) {
            return unescape(encodeURIComponent(str));
        },
        
        decodeUTF8: function(str) {
            return decodeURIComponent(escape(str));
        },
        
        // 效能監控
        now: function() {
            return performance.now();
        }
    };
    
    // YOLO 特定工具
    tf.yolo = {
        // 載入 YOLO 模型的便捷方法
        loadModel: async function(modelPath) {
            const model = new YOLOModel();
            model.modelPath = modelPath;
            await model.load();
            return model;
        },
        
        // 繪製偵測結果
        drawDetections: function(canvas, detections, options = {}) {
            const ctx = canvas.getContext('2d');
            const scale = options.scale || 1;
            
            // 設定繁體中文字體
            ctx.font = options.font || '16px "Microsoft JhengHei", "微軟正黑體", sans-serif';
            
            detections.forEach(detection => {
                const [x, y, w, h] = detection.bbox;
                
                // 繪製邊界框
                ctx.strokeStyle = options.color || '#00ff00';
                ctx.lineWidth = options.lineWidth || 2;
                ctx.strokeRect(x * scale, y * scale, w * scale, h * scale);
                
                // 繪製標籤
                const label = `${detection.className} ${(detection.score * 100).toFixed(1)}%`;
                const textWidth = ctx.measureText(label).width;
                
                // 標籤背景
                ctx.fillStyle = options.bgColor || 'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(x * scale, y * scale - 20, textWidth + 10, 20);
                
                // 標籤文字
                ctx.fillStyle = options.textColor || '#000000';
                ctx.fillText(label, x * scale + 5, y * scale - 5);
            });
        }
    };
    
    // 記憶體管理
    tf.memory = function() {
        return {
            numTensors: Tensor.totalCount || 0,
            numDataBuffers: Tensor.dataBufferCount || 0,
            numBytes: Tensor.totalBytes || 0
        };
    };
    
    // 匯出到全域
    global.tf = tf;
    
    // 相容性檢查
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = tf;
    }
    
    console.log('TensorFlow.js 精簡版載入完成 - 專為 EasyYOLO 優化');
    
})(typeof window !== 'undefined' ? window : global);